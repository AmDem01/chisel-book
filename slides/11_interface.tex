\input{slides_common}

\newif\ifbook
\input{../shared/chisel}

\title{Interfacing and Memory}
\author{Martin Schoeberl}
\date{\today}
\institute{Technical University of Denmark\\
Embedded Systems Engineering}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\begin{frame}[fragile]{TODO}
\begin{itemize}
\item UART
\item Did I do input processing last time? Done, but repeat
\item Busses (L11)
\item Memory
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Overview}
\begin{itemize}
\item Repeat FSMD (for the vending machine)
\item Interfaces
\item Memory (intern and extern)
\item 2 hours lab SRAM exercise
\begin{itemize}
\item Exercise description is in DTU Inside
\item \href{https://cn.inside.dtu.dk/cnnet/filesharing/download/39a98e6a-f453-4aa7-98c4-cb13eae6c805}{sram\_exercise.pdf}
\item \href{https://cn.inside.dtu.dk/cnnet/filesharing/download/618360ca-01b4-42e4-86e2-765835963deb}{SRAM data sheet: CYCC1041...}
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{The Online Exam}
\begin{itemize}
\item We will use the ``old'' online system
\item Show it at \url{http://onlineeksamen.dtu.dk/}
\item It will be two parts:
\begin{itemize}
\item Multiple choice
\item Download and hand in a document (e.g., PDF generated from Word)
\end{itemize}
\item You can play with the very short one today
\item We will do a test exam next week, before the lab
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Using an FSM and a Datapath}
\begin{itemize}
\item About the design of the vending machine (VM)
\item Some of you start coding the VM directly
\begin{itemize}
\item This may work for small designs
\item But does not scale
\end{itemize}
\item Better use a systematic approach
\item Use a FSM that communicates with a datapath (FSMD)
\item We will quickly repeat FSMD
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Finite-State Machine (FSM)}
\begin{itemize}
\item Has a register that contains the state
\item Has a function to computer the next state
\begin{itemize}
\item Depending on current state and input
\end{itemize}
\item Has an output depending on the state
\item Use a Moore FSM for the VM
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Basic Finite-State Machine}
\begin{itemize}
\item A state register
\item Two combinational blocks
\end{itemize}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/fsm}
\end{figure}
\end{frame}

\begin{frame}[fragile]{State Diagram}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/state-diag-moore}
\end{figure}
\begin{itemize}
\item States and transitions depending on input values
\item Example is a simple alarm FSM
\item Nice visualization
\item Draw the state diagram for your VM during the design
\item Include a state diagram in the report
\end{itemize}
\end{frame}



\begin{frame}[fragile]{The Input and Output of the Alarm FSM}
\begin{itemize}
\item Two inputs and one output
\end{itemize}
\shortlist{../code/simple_fsm_io.txt}
\end{frame}

\begin{frame}[fragile]{Encoding the State}
\begin{itemize}
\item We can optimize state encoding
\item Two common encodings are: binary and one-hot
\item We leave it to the synthesize tool
\item Use symbolic names with an \code{Enum}
\item Note the number of states in the \code{Enum} construct
\item We use a Scala list with the \code{::} operator
\end{itemize}
\shortlist{../code/simple_fsm_states.txt}
\end{frame}

\begin{frame}[fragile]{Start the FSM}
\begin{itemize}
\item We have a starting state on reset
\end{itemize}
\shortlist{../code/simple_fsm_register.txt}
\end{frame}


\begin{frame}[fragile]{The Next State Logic}
\shortlist{../code/simple_fsm_next.txt}
\end{frame}

\begin{frame}[fragile]{The Output Logic}
\shortlist{../code/simple_fsm_output.txt}
\end{frame}

\begin{frame}[fragile]{Summary on the Alarm Example}
\begin{itemize}
\item Three elements:
\begin{enumerate}
\item State register
\item Next state logic
\item Output logic
\end{enumerate}
\item This was a so-called Moore FSM
\item There is also an FSM type called Mealy machine
\end{itemize}
\end{frame}


\begin{frame}[fragile]{FSM with Datapath}
\begin{itemize}
\item A type of computing machine
\item Consists of a finite-state machine (FSM) and a datapath
\item The FSM is the master (the controller) of the datapath
\item The datapath has computing elements
\begin{itemize}
\item E.g., adder, incrementer, constants, multiplexers, ...
\end{itemize}
\item The datapath has storage elements (registers)
\begin{itemize}
\item E.g., sum of money payed, count of something, ...
\end{itemize}
\item You VM design shall be a FSMD
\end{itemize}
\end{frame}

\begin{frame}[fragile]{FSM-Datapath Interaction}
\begin{itemize}
\item The FSM controls the datapath
\begin{itemize}
\item For example, add 2 to the sum
\end{itemize}
\item By controlling multiplexers
\begin{itemize}
\item For example, select how much to add
\item Not adding means selecting 0 to add
\end{itemize}
\item Which value goes where
\item The FSM logic also depends on datapath output
\begin{itemize}
\item Is there enough money payed to release a can of soda?
\end{itemize}
\item FSM and datapath interact
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Popcount Example}
\begin{itemize}
\item An FSMD that computes the popcount
\item Also called the Hamming weight
\item Compute the number of `1's in a word
\item Input is the data word
\item Output is the count
\item Code available at \href{https://github.com/schoeberl/chisel-book/blob/master/src/main/scala/PopCount.scala}{PopCount.scala}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Popcount Block Diagram}

\begin{figure}
  \includegraphics[scale=\scale]{../figures/popcnt-fsmd}
\end{figure}
\end{frame}


\begin{frame}[fragile]{The FSM}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/popcnt-states}
\end{figure}
\begin{itemize}
\item A Very Simple FSM
\item Two transitions depend on input/output handshake
\item One transition on the datapath output
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The Datapath}
\begin{figure}
  \includegraphics[scale=0.65]{../figures/popcnt-data}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Let's Explore the Code}
\begin{itemize}
\item In \href{https://github.com/schoeberl/chisel-book/blob/master/src/main/scala/PopCount.scala}{PopCount.scala}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Usage of an FSMD}
\begin{itemize}
\item Of course for your VM
\begin{itemize}
\item The VM is a simple processor
\item But not Turing complete
\item Can \emph{only} process coins of 2 and 5
\end{itemize}
\item An FSMD can be used to build a processor
\item Fine for simple processors
\item E.g., \href{https://github.com/schoeberl/lipsi}{Lipsi}
\item Pipelined processor topic of
\begin{itemize}
\item Computer Architecture Engineering (02155)
\end{itemize}\end{itemize}
\end{frame}

\begin{frame}[fragile]{Use a FSMD for the VM}
\begin{itemize}
\item This is the main part your vending machine
\item Can be design and tested just with Chisel testers (no FPGA board needed)
\item See the given tester
\begin{itemize}
\item Sets the price to 7
\item Adds two coins (2 and 5)
\item Presses the buy button
\end{itemize}
\item Extend the test along the development
\begin{itemize}

\item Remember test driven development?
\item Maybe write the test before the implementation
\item Maybe test developer and FSMD developer are not always the same person
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Code Snippets}
\begin{chisel}
  val idle :: add2 ... :: Nil = Enum(?)
  val stateReg = RegInit(idle)
  ...
  switch (stateReg) {
    is (idle){
      when(coin2) {
        stateReg := ...
      }
      when(...) {
   ...
   switch(stateReg) {
     is (add2) { ... }  // drive the datapath for adding a coin 2
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Memory}
\begin{itemize}
\item Registers are storage elements == memory
\item Just use a \code{Reg} of a \code{Vec}
\item This is 1 KiB of memory
\begin{chisel}
  val memoryReg = Reg(Vec(1024, UInt(8.W)))
  // writing into memory
  memoryReg(wrAddr) := wrData
  // reading from the memory
  val rdData = memoryReg(rdAddr)
\end{chisel}
\item Simple, right?
\item But is this a good solution?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A Flip-Flop}
\begin{itemize}
\item Remember the circuit of a register (flip-flop)?
\item Two latches: \href{https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Master%E2%80%93slave_edge-triggered_D_flip-flop}{master and slave}
\item One (enable) latch can be built with 4 NAND gates
\item a NAND gate needs 6 transistors, an inverter 2 transistors
\item A flip-flop needs 20 transistors (for a single bit)
\item Can we do better?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A Memory Cell}
\begin{itemize}
\item A single bit can be stored in \href{https://en.wikipedia.org/wiki/Static_random-access_memory#/media/File:SRAM_Cell_(6_Transistors).svg}{6 transistors}
\item That is how larger memories are built
\item FPGAs have this type of on-chip memories
\item Usually many of them in units of 2 KiB or 4 KiB
\item We need some Chisel code to represent it
\item More memory needs an extra chip
\item Then we need to interface this memory from the FPGA
\end{itemize}
\end{frame}

\begin{frame}[fragile]{SRAM Memory}
\begin{itemize}
\item RAM stands for random access memory
\item SRAM stands for static RAM
\item There is also something called DRAM for dynamic RAM
\begin{itemize}
\item Uses a capacitor and a transistor
\item DRAM is smaller than SRAM
\item But needs refreshes
\item Different technology than technology for logic
\end{itemize}
\item All on-chip memory is SRAM (today)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Memory Interface}
\begin{itemize}
\item Interface
\begin{itemize}
\item Address input (e.g., 10 bits for 1 KiB)
\item Write signal (e.g., we)
\item Data input
\item Data output
\end{itemize}
\item May share pins for the data input and output (tri-state)
\item May have read and write address
\begin{itemize}
\item A so-called dual ported memory
\item Can do a read and a write in the same clock cycle
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{On-Chip Memory}
\begin{itemize}
\item SRAM by itself is asynchronous
\item No clock, just the correct timing
\item Apply the address and after some time the data is valid
\item But one can add input registers, which makes it a synchronous SRAM
\item Current FPGAs have only synchronous memories
\item FPGAs usually have dual-ported memories
\item This means the result of a read is available on clock cycle after the address is given
\begin{itemize}
\item This is different from the use of flip-flops (\code{Reg(Vec(..))})
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Synchronous Memory}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/memory}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Use of a Chisel SyncReadMem}
\shortlist{../code/memory.txt}
\end{frame}

\begin{frame}[fragile]{Read-During-Write}
\begin{itemize}
\item What happens when one writes to and reads from the same address?
\item Which value is returned?
\item Three possibilities:
\begin{enumerate}
\item The newly written value
\item The old value
\item Undefined (mix of old and new)
\end{enumerate}
\item Depends on technology, FPGA family, ...
\item We want to have a defined read-during-write
\item We add hardware to \emph{forward} the written value
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Condition for Forwarding}
\begin{itemize}
\item If read and write addresses are equal
\item If write enable is true
\item Multiplex the output to take the new write value instead of the (old) read value
\item Delay that forwarded write value to have the same timing
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Memory with Forwarding}
\begin{figure}
  \includegraphics[scale=0.5]{../figures/memory-forwarding}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Forwarding in Chisel}
\begin{chisel}
  val mem = SyncReadMem(1024, UInt(8.W))

  val wrDataReg = RegNext(io.wrData)
  val doForwardReg = RegNext(io.wrAddr === io.rdAddr && io.wrEna)

  val memData = mem.read(io.rdAddr)

  when(io.wrEna) {
    mem.write(io.wrAddr, io.wrData)
  }

  io.rdData := Mux(doForwardReg, wrDataReg, memData)
\end{chisel}
\end{frame}


\begin{frame}[fragile]{External Memory}
\begin{itemize}
\item On-chip memory is limited
\item We can add an external memory chip
\begin{itemize}
\item Is cheaper than FPGA on-chip memory
\end{itemize}
\item Sadly the Basys3 board has no external memory
\item Simple memory is an asynchronous SRAM
\end{itemize}
\end{frame}

\begin{frame}[fragile]{External SRAM}
\begin{itemize}
\item We \emph{buy} a CY7C1041CV33
\item Let us look into the \href{https://cn.inside.dtu.dk/cnnet/filesharing/download/618360ca-01b4-42e4-86e2-765835963deb}{data sheet}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Interfacing the SRAM}
\begin{itemize}
\item FPGA output drives address, control, and data (sometimes)
\item FPGA reads data
\item The read signal is asynchronous to the FPGA clock
\item Do we need an input synchronizer?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Synchronous Interface}
\begin{itemize}
\item Logic is synchroous
\item Memory is asynchronous
\begin{itemize}
\item How to interface?
\end{itemize}
\item Output signals
\begin{itemize}
\item Generate timing with synchronous circuit
\item Small FSM
\end{itemize}
\item Asynchronous input signale
\begin{itemize}
\item Usually 2 register for input synchronization
\item Really needed for the SRAM interface?
\item We would loose 2 clock cycles
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{SRAM Read}
\begin{itemize}
\item Asynchronous timing definition (data sheet)
\item But, we know the timing and we trigger the SRAM address from
our synchronous design
\item No need to use synchronization registers
\item \emph{Just} get the timing correct
\item Dra the example
\begin{itemize}
\item Address - SRAM - data
\item Relative to the FPGA clock
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Read Timing Continued}
\begin{itemize}
\item Add all time delays
\begin{itemize}
\item Within FPGA
\item Pad to pin
\item PSB traces
\item SRAM read timing
\item PCB traces back
\item Pin to pad
\item Into FPGA register
\end{itemize}
\item Setup and hold time for FPGA register
\item Is your today's lab exercise
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Busses}
\begin{itemize}
\item Memory interface can be generalized
\item We use a so-called bus to connect several devices
\item Usually a microprocessor connected to devices (memory, IO)
\item The microprocessor is the master
\item Draw a small microprocessor system
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}
\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}
\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}
\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}
\begin{frame}[fragile]{Today Lab}
\begin{itemize}
\item Paper \& pencil exercises on SRAM interfacing
\item On paper or in a plain text editor
\item As usual, show and discuss with a TA
\item Exercise description is in DTU Inside file sharing
\item \href{https://cn.inside.dtu.dk/cnnet/filesharing/download/39a98e6a-f453-4aa7-98c4-cb13eae6c805}{sram\_exercise.pdf}
\item \href{https://cn.inside.dtu.dk/cnnet/filesharing/download/618360ca-01b4-42e4-86e2-765835963deb}{SRAM data sheet: CYCC1041...}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}



\end{document}

%\begin{frame}[fragile]{xxx}
%\begin{itemize}
%\item yyy
%\end{itemize}
%\end{frame}
