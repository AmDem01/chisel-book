\input{slides_common}

\newif\ifbook
\input{../shared/chisel}

\title{Interfacing and Memory}
\author{Martin Schoeberl}
\date{\today}
\institute{Technical University of Denmark\\
Embedded Systems Engineering}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\begin{frame}[fragile]{TODO}
\begin{itemize}
\item Did I do input processing last time? Done, but repeat
\item Busses (L11)
\item Memory
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Overview}
\begin{itemize}
\item Repeat FSMD (for the vending machine)
\item Interfaces
\item Memory (intern and extern)
\item 2 hours lab SRAM exercise
\begin{itemize}
\item Exercise description is in DTU Inside
\item \href{https://cn.inside.dtu.dk/cnnet/filesharing/download/39a98e6a-f453-4aa7-98c4-cb13eae6c805}{sram\_exercise.pdf}
\item \href{https://cn.inside.dtu.dk/cnnet/filesharing/download/618360ca-01b4-42e4-86e2-765835963deb}{SRAM data sheet: CYCC1041...}
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{The Online Exam}
\begin{itemize}
\item We will use the ``old'' online system
\item Show it at \url{http://onlineeksamen.dtu.dk/}
\item It will be two parts:
\begin{itemize}
\item Multiple choice
\item Download and hand in a document (e.g., PDF generated from Word)
\end{itemize}
\item You can play with the very short one today
\item We will do a test exam next week, before the lab
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Using an FSM and a Datapath}
\begin{itemize}
\item About the design of the vending machine (VM)
\item Some of you start coding the VM directly
\begin{itemize}
\item This may work for small designs
\item But does not scale
\end{itemize}
\item Better use a systematic approach
\item Use a FSM that communicates with a datapath (FSMD)
\item We will quickly repeat FSMD
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Finite-State Machine (FSM)}
\begin{itemize}
\item Has a register that contains the state
\item Has a function to computer the next state
\begin{itemize}
\item Depending on current state and input
\end{itemize}
\item Has an output depending on the state
\item Use a Moore FSM for the VM
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Basic Finite-State Machine}
\begin{itemize}
\item A state register
\item Two combinational blocks
\end{itemize}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/fsm}
\end{figure}
\end{frame}

\begin{frame}[fragile]{State Diagram}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/state-diag-moore}
\end{figure}
\begin{itemize}
\item States and transitions depending on input values
\item Example is a simple alarm FSM
\item Nice visualization
\item Draw the state diagram for your VM during the design
\item Include a state diagram in the report
\end{itemize}
\end{frame}



\begin{frame}[fragile]{The Input and Output of the Alarm FSM}
\begin{itemize}
\item Two inputs and one output
\end{itemize}
\shortlist{../code/simple_fsm_io.txt}
\end{frame}

\begin{frame}[fragile]{Encoding the State}
\begin{itemize}
\item We can optimize state encoding
\item Two common encodings are: binary and one-hot
\item We leave it to the synthesize tool
\item Use symbolic names with an \code{Enum}
\item Note the number of states in the \code{Enum} construct
\item We use a Scala list with the \code{::} operator
\end{itemize}
\shortlist{../code/simple_fsm_states.txt}
\end{frame}

\begin{frame}[fragile]{Start the FSM}
\begin{itemize}
\item We have a starting state on reset
\end{itemize}
\shortlist{../code/simple_fsm_register.txt}
\end{frame}


\begin{frame}[fragile]{The Next State Logic}
\shortlist{../code/simple_fsm_next.txt}
\end{frame}

\begin{frame}[fragile]{The Output Logic}
\shortlist{../code/simple_fsm_output.txt}
\end{frame}

\begin{frame}[fragile]{Summary on the Alarm Example}
\begin{itemize}
\item Three elements:
\begin{enumerate}
\item State register
\item Next state logic
\item Output logic
\end{enumerate}
\item This was a so-called Moore FSM
\item There is also an FSM type called Mealy machine
\end{itemize}
\end{frame}


\begin{frame}[fragile]{FSM with Datapath}
\begin{itemize}
\item A type of computing machine
\item Consists of a finite-state machine (FSM) and a datapath
\item The FSM is the master (the controller) of the datapath
\item The datapath has computing elements
\begin{itemize}
\item E.g., adder, incrementer, constants, multiplexers, ...
\end{itemize}
\item The datapath has storage elements (registers)
\begin{itemize}
\item E.g., sum of money payed, count of something, ...
\end{itemize}
\item You VM design shall be a FSMD
\end{itemize}
\end{frame}

\begin{frame}[fragile]{FSM-Datapath Interaction}
\begin{itemize}
\item The FSM controls the datapath
\begin{itemize}
\item For example, add 2 to the sum
\end{itemize}
\item By controlling multiplexers
\begin{itemize}
\item For example, select how much to add
\item Not adding means selecting 0 to add
\end{itemize}
\item Which value goes where
\item The FSM logic also depends on datapath output
\begin{itemize}
\item Is there enough money payed to release a can of soda?
\end{itemize}
\item FSM and datapath interact
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Popcount Example}
\begin{itemize}
\item An FSMD that computes the popcount
\item Also called the Hamming weight
\item Compute the number of `1's in a word
\item Input is the data word
\item Output is the count
\item Code available at \href{https://github.com/schoeberl/chisel-book/blob/master/src/main/scala/PopCount.scala}{PopCount.scala}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Popcount Block Diagram}

\begin{figure}
  \includegraphics[scale=\scale]{../figures/popcnt-fsmd}
\end{figure}
\end{frame}


\begin{frame}[fragile]{The FSM}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/popcnt-states}
\end{figure}
\begin{itemize}
\item A Very Simple FSM
\item Two transitions depend on input/output handshake
\item One transition on the datapath output
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The Datapath}
\begin{figure}
  \includegraphics[scale=0.65]{../figures/popcnt-data}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Let's Explore the Code}
\begin{itemize}
\item In \href{https://github.com/schoeberl/chisel-book/blob/master/src/main/scala/PopCount.scala}{PopCount.scala}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Usage of an FSMD}
\begin{itemize}
\item Of course for your VM
\begin{itemize}
\item The VM is a simple processor
\item But not Turing complete
\item Can \emph{only} process coins of 2 and 5
\end{itemize}
\item An FSMD can be used to build a processor
\item Fine for simple processors
\item E.g., \href{https://github.com/schoeberl/lipsi}{Lipsi}
\item Pipelined processor topic of
\begin{itemize}
\item Computer Architecture Engineering (02155)
\end{itemize}\end{itemize}
\end{frame}

\begin{frame}[fragile]{Use a FSMD for the VM}
\begin{itemize}
\item This is the main part your vending machine
\item Can be design and tested just with Chisel testers (no FPGA board needed)
\item See the given tester
\begin{itemize}
\item Sets the price to 7
\item Adds two coins (2 and 5)
\item Presses the buy button
\end{itemize}
\item Extend the test along the development
\begin{itemize}

\item Remember test driven development?
\item Maybe write the test before the implementation
\item Maybe test developer and FSMD developer are not always the same person
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Code Snippets}
\begin{chisel}
  val idle :: add2 ... :: Nil = Enum(?)
  val stateReg = RegInit(idle)
  ...
  switch (stateReg) {
    is (idle){
      when(coin2) {
        stateReg := ...
      }
      when(...) {
   ...
   switch(stateReg) {
     is (add2) { ... }  // drive the datapath for adding a coin 2
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Memory}
\begin{itemize}
\item Registers are storage elements == memory
\item Just use a \code{Reg} of a \code{Vec}
\item This is 1 KiB of memory
\begin{chisel}
  val memoryReg = Reg(Vec(1024, UInt(8.W)))
  // writing into memory
  memoryReg(wrAddr) := wrData
  // reading from the memory
  val rdData = memoryReg(rdAddr)
\end{chisel}
\item Simple, right?
\item But is this a good solution?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A Flip-Flop}
\begin{itemize}
\item Remember the circuit of a register (flip-flop)?
\item Two latches: \href{https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Master%E2%80%93slave_edge-triggered_D_flip-flop}{master and slave}
\item One (enable) latch can be built with 4 NAND gates
\item a NAND gate needs 6 transistors, an inverter 2 transistors
\item A flip-flop needs 20 transistors (for a single bit)
\item Can we do better?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A Memory Cell}
\begin{itemize}
\item A single bit can be stored in \href{https://en.wikipedia.org/wiki/Static_random-access_memory#/media/File:SRAM_Cell_(6_Transistors).svg}{6 transistors}
\item That is how larger memories are built
\item FPGAs have this type of on-chip memories
\item Usually many of them in units of 2 KiB or 4 KiB
\item We need some Chisel code to represent it
\item More memory needs an extra chip
\item then we need to interface this memory from the FPGA
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Today Lab}
\begin{itemize}
\item Paper \& pencil exercises on SRAM interfacing
\item On paper or in a plain text editor
\item As usual, show and discuss with a TA
\item Exercise description is in DTU Inside file sharing
\item \href{https://cn.inside.dtu.dk/cnnet/filesharing/download/39a98e6a-f453-4aa7-98c4-cb13eae6c805}{sram\_exercise.pdf}
\item \href{https://cn.inside.dtu.dk/cnnet/filesharing/download/618360ca-01b4-42e4-86e2-765835963deb}{SRAM data sheet: CYCC1041...}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}



\end{document}

%\begin{frame}[fragile]{xxx}
%\begin{itemize}
%\item yyy
%\end{itemize}
%\end{frame}
